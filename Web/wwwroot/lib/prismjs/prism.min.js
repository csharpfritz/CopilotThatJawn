/* PrismJS 1.29.0 - Core and Language Support */
(function() {
    'use strict';

    var Prism = {
        manual: false,
        disableWorkerMessageHandler: false,
        
        util: {
            encode: function(tokens) {
                if (tokens instanceof Token) {
                    return new Token(tokens.type, Prism.util.encode(tokens.content), tokens.alias);
                } else if (Array.isArray(tokens)) {
                    return tokens.map(Prism.util.encode);
                } else {
                    return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
                }
            },
            type: function(o) {
                return Object.prototype.toString.call(o).slice(8, -1);
            },
            objId: function(obj) {
                if (!obj['__id']) {
                    Object.defineProperty(obj, '__id', {
                        value: ++uniqueId
                    });
                }
                return obj['__id'];
            },
            clone: function(o, visited) {
                var type = Prism.util.type(o);
                visited = visited || {};

                switch (type) {
                    case 'Object':
                        if (visited[Prism.util.objId(o)]) {
                            return visited[Prism.util.objId(o)];
                        }
                        var clone = {};
                        visited[Prism.util.objId(o)] = clone;

                        for (var key in o) {
                            if (o.hasOwnProperty(key)) {
                                clone[key] = Prism.util.clone(o[key], visited);
                            }
                        }

                        return clone;

                    case 'Array':
                        if (visited[Prism.util.objId(o)]) {
                            return visited[Prism.util.objId(o)];
                        }
                        var clone = [];
                        visited[Prism.util.objId(o)] = clone;

                        for (var i = 0; i < o.length; i++) {
                            clone[i] = Prism.util.clone(o[i], visited);
                        }

                        return clone;
                }

                return o;
            }
        },

        languages: {
            extend: function(id, redef) {
                var lang = Prism.util.clone(Prism.languages[id]);
                for (var key in redef) {
                    lang[key] = redef[key];
                }
                return lang;
            },
            insertBefore: function(inside, before, insert, root) {
                root = root || Prism.languages;
                var grammar = root[inside];
                if (arguments.length == 2) {
                    insert = arguments[1];
                    for (var newToken in insert) {
                        if (insert.hasOwnProperty(newToken)) {
                            grammar[newToken] = insert[newToken];
                        }
                    }
                    return grammar;
                }
                var ret = {};
                for (var token in grammar) {
                    if (grammar.hasOwnProperty(token)) {
                        if (token == before) {
                            for (var newToken in insert) {
                                if (insert.hasOwnProperty(newToken)) {
                                    ret[newToken] = insert[newToken];
                                }
                            }
                        }
                        ret[token] = grammar[token];
                    }
                }
                root[inside] = ret;
                return ret;
            },
            DFS: function(o, callback, type, visited) {
                visited = visited || {};
                for (var i in o) {
                    if (o.hasOwnProperty(i)) {
                        callback.call(o, i, o[i], type || i);
                        if (Prism.util.type(o[i]) === 'Object' && !visited[Prism.util.objId(o[i])]) {
                            visited[Prism.util.objId(o[i])] = true;
                            Prism.languages.DFS(o[i], callback, null, visited);
                        } else if (Prism.util.type(o[i]) === 'Array' && !visited[Prism.util.objId(o[i])]) {
                            visited[Prism.util.objId(o[i])] = true;
                            Prism.languages.DFS(o[i], callback, i, visited);
                        }
                    }
                }
            }
        },

        plugins: {},

        highlight: function(text, grammar, language) {
            var env = {
                code: text,
                grammar: grammar,
                language: language
            };
            Prism.hooks.run('before-tokenize', env);
            env.tokens = Prism.tokenize(env.code, env.grammar);
            Prism.hooks.run('after-tokenize', env);
            return Token.stringify(Prism.util.encode(env.tokens), env.language);
        },

        tokenize: function(text, grammar) {
            var strarr = [text];
            var rest = grammar.rest;
            if (rest) {
                for (var token in rest) {
                    grammar[token] = rest[token];
                }
                delete grammar.rest;
            }
            tokenloop: for (var token in grammar) {
                if (!grammar.hasOwnProperty(token) || !grammar[token]) {
                    continue;
                }
                var patterns = grammar[token];
                patterns = (Prism.util.type(patterns) === "Array") ? patterns : [patterns];
                for (var j = 0; j < patterns.length; ++j) {
                    var pattern = patterns[j],
                        inside = pattern.inside,
                        lookbehind = !!pattern.lookbehind,
                        greedy = !!pattern.greedy,
                        lookbehindLength = 0,
                        alias = pattern.alias;
                    if (greedy && !pattern.pattern.global) {
                        var flags = pattern.pattern.toString().match(/[gimuy]*$/)[0];
                        pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
                    }
                    pattern = pattern.pattern || pattern;
                    for (var i = 0, pos = 0; i < strarr.length; pos += strarr[i].length, ++i) {
                        var str = strarr[i];
                        if (strarr.length > text.length) {
                            break tokenloop;
                        }
                        if (str instanceof Token) {
                            continue;
                        }
                        if (greedy && i != strarr.length - 1) {
                            pattern.lastIndex = pos;
                            var match = pattern.exec(text);
                            if (!match) {
                                break;
                            }
                            var from = match.index + (lookbehind ? match[1].length : 0),
                                to = match.index + match[0].length,
                                k = i,
                                p = pos;
                            for (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {
                                p += strarr[k].length;
                                if (from >= p) {
                                    ++i;
                                    pos = p;
                                }
                            }
                            if (strarr[i] instanceof Token) {
                                continue;
                            }
                            delNum = k - i;
                            str = text.slice(pos, p);
                            match.index -= pos;
                        } else {
                            pattern.lastIndex = 0;
                            var match = pattern.exec(str),
                                delNum = 1;
                        }
                        if (!match) {
                            if (greedy) {
                                break;
                            }
                            continue;
                        }
                        if (lookbehind) {
                            lookbehindLength = match[1] ? match[1].length : 0;
                        }
                        var from = match.index + lookbehindLength,
                            match = match[0].slice(lookbehindLength),
                            to = from + match.length,
                            before = str.slice(0, from),
                            after = str.slice(to);
                        var args = [i, delNum];
                        if (before) {
                            ++i;
                            pos += before.length;
                            args.push(before);
                        }
                        var wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);
                        args.push(wrapped);
                        if (after) {
                            args.push(after);
                        }
                        Array.prototype.splice.apply(strarr, args);
                        if (delNum != 1)
                            Prism.tokenize.matchGrammar(text, strarr, grammar, i, pos, true, token);
                        if (greedy)
                            break;
                    }
                }
            }
            return strarr;
        },

        hooks: {
            all: {},
            add: function(name, callback) {
                var hooks = Prism.hooks.all;
                hooks[name] = hooks[name] || [];
                hooks[name].push(callback);
            },
            run: function(name, env) {
                var callbacks = Prism.hooks.all[name];
                if (!callbacks || !callbacks.length) {
                    return;
                }
                for (var i = 0, callback; callback = callbacks[i++];) {
                    callback(env);
                }
            }
        }
    };

    var Token = Prism.Token = function(type, content, alias, matchedStr, greedy) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
        this.greedy = !!greedy;
    };

    Token.stringify = function(o, language, parent) {
        if (typeof o == 'string') {
            return o;
        }
        if (Array.isArray(o)) {
            return o.map(function(element) {
                return Token.stringify(element, language, o);
            }).join('');
        }
        var env = {
            type: o.type,
            content: Token.stringify(o.content, language, parent),
            tag: 'span',
            classes: ['token', o.type],
            attributes: {},
            language: language,
            parent: parent
        };
        if (o.alias) {
            var aliases = Array.isArray(o.alias) ? o.alias : [o.alias];
            Array.prototype.push.apply(env.classes, aliases);
        }
        Prism.hooks.run('wrap', env);
        var attributes = Object.keys(env.attributes).map(function(name) {
            return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
        }).join(' ');
        return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
    };

    var uniqueId = 0;

    // Basic language definitions
    Prism.languages.clike = {
        'comment': [
            {
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true
            },
            {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        'string': {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        'class-name': {
            pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
            lookbehind: true,
            inside: {
                'punctuation': /[.\\]/
            }
        },
        'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
        'boolean': /\b(?:true|false)\b/,
        'function': /\w+(?=\()/,
        'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
        'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        'punctuation': /[{}[\];(),.:]/
    };

    // C# language definition
    Prism.languages.csharp = Prism.languages.extend('clike', {
        'string': [
            {
                pattern: /@("|')(?:\1\1|\\[\s\S]|(?!\1)[^\\])*\1/,
                greedy: true
            },
            {
                pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*?\1/,
                greedy: true
            }
        ],
        'class-name': [
            {
                pattern: /(\b(?:class|interface|new|where|struct)\s+)[\w.<>]+/,
                lookbehind: true,
                inside: {
                    'punctuation': /[<>.]/
                }
            },
            {
                pattern: /(\b(?:public|private|protected|internal|static|readonly|sealed|abstract|virtual|override|extern|async|partial|const|implicit|explicit|operator)\s+)*[\w.<>]+(?=\s+(?:(?:\w+\s*[,=\)])|(?:\[[\s\w\.,]*\]\s*[\w\s=\)])))/,
                inside: {
                    'punctuation': /[<>.]/
                }
            }
        ],
        'keyword': /\b(?:abstract|as|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|partial|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|var|virtual|void|volatile|where|while|yield)\b/,
        'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?[flmu]?\b/i,
        'operator': />>=?|<<=?|[-=]>|([-+&|])\1|~|[-+*/%&|^!=<>]=?/,
        'punctuation': /\?\.?|::|[{}[\];(),.:]/
    });

    // JavaScript language definition
    Prism.languages.javascript = Prism.languages.extend('clike', {
        'class-name': [
            Prism.languages.clike['class-name'],
            {
                pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
                lookbehind: true
            }
        ],
        'keyword': [
            {
                pattern: /((?:^|})\s*)(?:catch|finally)\b/,
                lookbehind: true
            },
            {
                pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\s*[\[\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
                lookbehind: true
            }
        ],
        'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
        'function': /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });

    // JSON language definition
    Prism.languages.json = {
        'property': {
            pattern: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
            greedy: true
        },
        'string': {
            pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
            greedy: true
        },
        'comment': /\/\/.*|\/\*[\s\S]*?\*\//,
        'number': /-?\d+\.?\d*(?:e[+-]?\d+)?/i,
        'punctuation': /[{}[\],]/,
        'operator': /:/,
        'boolean': /\b(?:true|false)\b/,
        'null': {
            pattern: /\bnull\b/,
            alias: 'keyword'
        }
    };

    // PowerShell language definition
    Prism.languages.powershell = {
        'comment': [
            {
                pattern: /(^|[^`])<#[\s\S]*?#>/,
                lookbehind: true
            },
            {
                pattern: /(^|[^`])#.*/,
                lookbehind: true
            }
        ],
        'string': [
            {
                pattern: /"(?:`[\s\S]|[^`"])*"/,
                greedy: true,
                inside: {
                    'function': {
                        pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
                        lookbehind: true,
                        inside: {}
                    }
                }
            },
            {
                pattern: /'(?:[^']|'')*'/,
                greedy: true
            }
        ],
        'namespace': /\[[a-z](?:\[(?:\[[^\]]*]|[^\[\]])*]|[^\[\]])*]/i,
        'boolean': /\$(?:true|false)\b/i,
        'variable': /\$\w+\b/,
        'function': [
            /\b(?:filter|function)\s+(?:\w+-)?\w+\b/i,
            {
                pattern: /(\.)(?:\w+-)?\w+\b/,
                lookbehind: true
            },
            /\b(?:\w+-)?\w+(?=-)|\b\w+(?=\()/
        ],
        'keyword': /\b(?:begin|break|catch|class|continue|data|define|do|dynamicparam|else|elseif|end|exit|filter|finally|for|foreach|from|function|if|in|param|process|return|switch|throw|trap|try|until|using|var|while|workflow|parallel|sequence|inlinescript|configuration)\b/i,
        'operator': [
            /\-(?:eq|ne|gt|ge|lt|le|sh[lr]|not|b?(?:and|x?or)|(?:Not)?(?:Like|Match|Contains|In)|Replace|Join|is(?:Not)?|as)\b/i,
            /[+\-*\/%]=|\+\+|--|&&|\|\||[<>=!]=?|[+\-*\/%]|\b(?:and|or|not)\b/i
        ],
        'punctuation': /[|{}[\];(),.]/
    };

    // Initialize highlighting
    if (!Prism.manual) {
        var script = document.currentScript || [].slice.call(document.getElementsByTagName('script')).pop();
        if (script) {
            Prism.filename = script.src;
            if (script.hasAttribute('data-manual')) {
                Prism.manual = true;
            }
        }

        if (!Prism.manual) {
            function highlightAll(async, callback) {
                if (async === undefined) async = true;
                if (callback === undefined) callback = null;

                var env = {
                    callback: callback,
                    selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                };

                Prism.hooks.run("before-highlightall", env);

                var elements = document.querySelectorAll(env.selector);
                for (var i = 0; i < elements.length; i++) {
                    highlightElement(elements[i], async === true, env.callback);
                }
            }

            function highlightElement(element, async, callback) {
                var language, grammar, parent = element;
                while (parent && !(/pre/i.test(parent.nodeName))) {
                    parent = parent.parentNode;
                }
                if (parent) {
                    language = (parent.className.match(/\blang(?:uage)?-([\w-]+)\b/i) || [, ''])[1];
                }
                if (!language) {
                    language = (element.className.match(/\blang(?:uage)?-([\w-]+)\b/i) || [, ''])[1];
                }
                if (!language) {
                    return;
                }
                element.className = element.className.replace(/\bno-highlight\b/, '');
                grammar = Prism.languages[language];
                if (!grammar) {
                    return;
                }
                element.className += ' language-' + language;
                parent = element.parentNode;
                if (parent && /pre/i.test(parent.nodeName)) {
                    parent.className += ' language-' + language;
                }
                var code = element.textContent;
                if (!code) {
                    return;
                }
                Prism.hooks.run('before-highlight', {
                    element: element,
                    code: code,
                    grammar: grammar,
                    language: language
                });
                element.innerHTML = Prism.highlight(code, grammar, language);
                Prism.hooks.run('after-highlight', {
                    element: element,
                    code: code,
                    grammar: grammar,
                    language: language
                });
            }

            Prism.highlightAll = highlightAll;
            Prism.highlightElement = highlightElement;

            if (document.readyState !== 'loading') {
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(highlightAll);
                } else {
                    window.setTimeout(highlightAll, 16);
                }
            } else {
                document.addEventListener('DOMContentLoaded', highlightAll);
            }
        }
    }

    window.Prism = Prism;
})();
                        visited[Prism.util.objId(o)] = clone;

                        o.forEach(function(v, i) {
                            clone[i] = Prism.util.clone(v, visited);
                        });

                        return clone;

                    default:
                        return o;
                }
            }
        },

        languages: {
            extend: function(id, redef) {
                var lang = Prism.util.clone(Prism.languages[id]);

                for (var key in redef) {
                    lang[key] = redef[key];
                }

                return lang;
            },

            insertBefore: function(inside, before, insert, root) {
                root = root || Prism.languages;
                var grammar = root[inside];
                var ret = {};

                for (var token in grammar) {
                    if (grammar.hasOwnProperty(token)) {
                        if (token == before) {
                            for (var newToken in insert) {
                                if (insert.hasOwnProperty(newToken)) {
                                    ret[newToken] = insert[newToken];
                                }
                            }
                        }
                        ret[token] = grammar[token];
                    }
                }

                var old = root[inside];
                root[inside] = ret;
                return old;
            },

            DFS: function(o, callback, type, visited) {
                visited = visited || {};
                for (var i in o) {
                    if (o.hasOwnProperty(i)) {
                        callback.call(o, i, o[i], type || i);

                        if (Prism.util.type(o[i]) === 'Object' && !visited[Prism.util.objId(o[i])]) {
                            visited[Prism.util.objId(o[i])] = true;
                            Prism.util.languages.DFS(o[i], callback, null, visited);
                        } else if (Prism.util.type(o[i]) === 'Array' && !visited[Prism.util.objId(o[i])]) {
                            visited[Prism.util.objId(o[i])] = true;
                            Prism.util.languages.DFS(o[i], callback, i, visited);
                        }
                    }
                }
            }
        },
        plugins: {},

        highlight: function(text, grammar, language) {
            var env = {
                code: text,
                grammar: grammar,
                language: language
            };
            Prism.hooks.run('before-tokenize', env);
            env.tokens = Prism.tokenize(env.code, env.grammar);
            Prism.hooks.run('after-tokenize', env);
            return Token.stringify(Prism.util.encode(env.tokens), env.language);
        },

        tokenize: function(text, grammar) {
            var rest = grammar.rest;
            if (rest) {
                for (var token in rest) {
                    grammar[token] = rest[token];
                }
                delete grammar.rest;
            }

            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text);

            matchGrammar(text, tokenList, grammar, tokenList.head, 0);

            return toArray(tokenList);
        },

        hooks: {
            all: {},
            add: function(name, callback) {
                var hooks = Prism.hooks.all;
                hooks[name] = hooks[name] || [];
                hooks[name].push(callback);
            },
            run: function(name, env) {
                var callbacks = Prism.hooks.all[name];
                if (!callbacks || !callbacks.length) {
                    return;
                }
                for (var i = 0, callback; callback = callbacks[i++];) {
                    callback(env);
                }
            }
        },

        Token: Token
    };

    function Token(type, content, alias, matchedStr, greedy) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || '').length | 0;
        this.greedy = !!greedy;
    }

    Token.stringify = function(o, language) {
        if (typeof o == 'string') {
            return o;
        }

        if (Array.isArray(o)) {
            return o.map(function(element) {
                return Token.stringify(element, language);
            }).join('');
        }

        var env = {
            type: o.type,
            content: Token.stringify(o.content, language),
            tag: 'span',
            classes: ['token', o.type],
            attributes: {},
            language: language
        };

        if (o.alias) {
            var aliases = Array.isArray(o.alias) ? o.alias : [o.alias];
            Array.prototype.push.apply(env.classes, aliases);
        }

        Prism.hooks.run('wrap', env);

        var attributes = Object.keys(env.attributes).map(function(name) {
            return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
        }).join(' ');

        return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
    };

    function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;

        this.head = head;
        this.tail = tail;
        this.length = 0;
    }

    function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value: value, prev: node, next: next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
    }

    function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
            array.push(node.value);
            node = node.next;
        }
        return array;
    }

    function matchGrammar(text, tokenList, grammar, startNode, startPos, oneshot, target) {
        for (var token in grammar) {
            if (!grammar.hasOwnProperty(token) || !grammar[token]) {
                continue;
            }

            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [patterns];

            for (var j = 0; j < patterns.length; ++j) {
                var pattern = patterns[j];
                var inside = pattern.inside;
                var lookbehind = !!pattern.lookbehind;
                var greedy = !!pattern.greedy;
                var lookbehindLength = 0;
                var alias = pattern.alias;

                if (greedy && !pattern.pattern.global) {
                    var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
                    pattern.pattern = RegExp(pattern.pattern.source, flags + 'g');
                }

                pattern = pattern.pattern || pattern;

                for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
                    var str = currentNode.value;
                    if (tokenList.length > text.length) {
                        return;
                    }

                    if (str instanceof Token) {
                        continue;
                    }

                    var removeCount = 1;
                    var match;

                    if (greedy && currentNode !== tokenList.tail.prev) {
                        pattern.lastIndex = pos;
                        match = pattern.exec(text);
                        if (!match) {
                            break;
                        }

                        var from = match.index + (lookbehind && match[1] ? match[1].length : 0);
                        var to = match.index + match[0].length;
                        var p = pos;

                        p += currentNode.value.length;
                        while (from >= p) {
                            currentNode = currentNode.next;
                            p += currentNode.value.length;
                        }

                        p -= currentNode.value.length;
                        pos = p;

                        if (currentNode.value instanceof Token) {
                            continue;
                        }

                        for (var k = currentNode; k !== tokenList.tail && (p < to || (typeof k.value === 'string' && !k.prev.value.greedy)); k = k.next) {
                            removeCount++;
                            p += k.value.length;
                        }
                        removeCount--;

                        str = text.slice(pos, p);
                        match.index -= pos;
                    } else {
                        pattern.lastIndex = 0;
                        match = pattern.exec(str);
                    }

                    if (!match) {
                        if (oneshot) {
                            break;
                        }
                        continue;
                    }

                    if (lookbehind) {
                        lookbehindLength = match[1] ? match[1].length : 0;
                    }

                    var from = match.index + lookbehindLength;
                    var match = match[0].slice(lookbehindLength);
                    var to = from + match.length;
                    var before = str.slice(0, from);
                    var after = str.slice(to);

                    var removeFrom = currentNode.prev;

                    if (before) {
                        removeFrom = addAfter(tokenList, removeFrom, before);
                        pos += before.length;
                    }

                    removeRange(tokenList, removeFrom, removeCount);

                    var wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);
                    currentNode = addAfter(tokenList, removeFrom, wrapped);

                    if (after) {
                        addAfter(tokenList, currentNode, after);
                    }

                    if (removeCount > 1) {
                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, true, token);
                    }

                    if (oneshot) {
                        break;
                    }
                }
            }
        }
    }

    function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
            next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= count;
    }

    var uniqueId = 0;

    // Basic language definitions
    Prism.languages.markup = {
        'comment': /<!--[\s\S]*?-->/,
        'prolog': /<\?[\s\S]+?\?>/,
        'doctype': {
            pattern: /<!DOCTYPE[\s\S]+?>/i,
            greedy: true
        },
        'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
        'tag': {
            pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/i,
            greedy: true,
            inside: {
                'tag': {
                    pattern: /^<\/?[^\s>\/]+/i,
                    inside: {
                        'punctuation': /^<\/?/,
                        'namespace': /^[^\s>\/:]+:/
                    }
                },
                'attr-value': {
                    pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,
                    inside: {
                        'punctuation': [
                            /^=/,
                            {
                                pattern: /^(\s*)["']|["']$/,
                                lookbehind: true
                            }
                        ]
                    }
                },
                'punctuation': /\/?>/,
                'attr-name': {
                    pattern: /[^\s>\/]+/,
                    inside: {
                        'namespace': /^[^\s>\/:]+:/
                    }
                }
            }
        },
        'entity': /&#?[\da-z]{1,8};/i
    };

    Prism.languages.html = Prism.languages.markup;
    Prism.languages.xml = Prism.languages.extend('markup', {});
    Prism.languages.svg = Prism.languages.markup;

    Prism.languages.css = {
        'comment': /\/\*[\s\S]*?\*\//,
        'atrule': {
            pattern: /@[\w-]+[\s\S]*?(?:;|(?=\s*\{))/,
            inside: {
                'rule': /^@[\w-]+/,
                'selector-function-argument': {
                    pattern: /(\bselector\s*\((?:\([^()]*\)|[^()])*?\))/i,
                    lookbehind: true,
                    alias: 'selector'
                }
            }
        },
        'url': {
            pattern: RegExp('\\burl\\((?:' + /"(?:[^"\\\r\n]|\\[\s\S])*"|'(?:[^'\\\r\n]|\\[\s\S])*'/.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
            greedy: true,
            inside: {
                'function': /^url/i,
                'punctuation': /^\(|\)$/
            }
        },
        'selector': RegExp('[^{}\\s](?:[^{};"\']|' + /"(?:[^"\\\r\n]|\\[\s\S])*"|'(?:[^'\\\r\n]|\\[\s\S])*'/.source + ')*?(?=\\s*\\{)'),
        'string': {
            pattern: /("|')(?:(?!\1)[^\\\r\n]|\\[\s\S])*\1/,
            greedy: true
        },
        'property': /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
        'important': /!important\b/i,
        'function': /[-a-z0-9]+(?=\()/i,
        'punctuation': /[(){};:,]/
    };

    Prism.languages.javascript = Prism.languages.extend('clike', {
        'class-name': [
            Prism.languages.clike['class-name'],
            {
                pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
                lookbehind: true
            }
        ],
        'keyword': [
            {
                pattern: /((?:^|})\s*)(?:catch|finally)\b/,
                lookbehind: true
            },
            {
                pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
                lookbehind: true
            }
        ],
        'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
        'function': /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });

    Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;

    Prism.languages.insertBefore('javascript', 'keyword', {
        'regex': {
            pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
            lookbehind: true,
            greedy: true
        },
        'function-variable': {
            pattern: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
            alias: 'function'
        },
        'parameter': [
            {
                pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
                inside: Prism.languages.javascript
            },
            {
                pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
                lookbehind: true,
                inside: Prism.languages.javascript
            }
        ],
        'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });

    Prism.languages.insertBefore('javascript', 'string', {
        'template-string': {
            pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
            greedy: true,
            inside: {
                'template-punctuation': {
                    pattern: /^`|`$/,
                    alias: 'string'
                },
                'interpolation': {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
                    lookbehind: true,
                    inside: {
                        'interpolation-punctuation': {
                            pattern: /^\${|}$/,
                            alias: 'punctuation'
                        },
                        rest: Prism.languages.javascript
                    }
                },
                'string': /[\s\S]+/
            }
        }
    });

    // C# Language
    Prism.languages.csharp = Prism.languages.extend('clike', {
        'string': [
            {
                pattern: RegExp(/(^|[^\\])/.source + '(?:' + /"(?:\\.|[^"\\])*"/.source + '|' + /@"(?:""|[^"])*"/.source + ')'),
                lookbehind: true,
                greedy: true
            }
        ],
        'class-name': [
            {
                pattern: RegExp(/\b[A-Z](?:\d|\w)*\b/.source),
                inside: {
                    'punctuation': /[.]/
                }
            }
        ],
        'keyword': /\b(?:abstract|add|alias|as|ascending|async|await|base|bool|break|by|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|equals|event|explicit|extern|false|finally|fixed|float|for|foreach|from|get|global|goto|group|if|implicit|in|int|interface|internal|into|is|join|let|lock|long|namespace|new|null|object|operator|orderby|out|override|params|partial|private|protected|public|readonly|ref|remove|return|sbyte|sealed|select|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|value|var|virtual|void|volatile|where|while|yield)\b/,
        'number': /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:ul|lu|[dflmu])?\b/i,
        'operator': />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
        'punctuation': /\?\.?|::|[{}[\];(),.:]/
    });

    Prism.languages.insertBefore('csharp', 'number', {
        'range': {
            pattern: /\.\./,
            alias: 'operator'
        }
    });

    Prism.languages.insertBefore('csharp', 'punctuation', {
        'named-parameter': {
            pattern: RegExp(/([(,]\s*)/.source + /[_a-zA-Z]\w*/.source + /(?=\s*:)/.source),
            lookbehind: true,
            alias: 'punctuation'
        }
    });

    Prism.languages.insertBefore('csharp', 'class-name', {
        'namespace': {
            pattern: RegExp(/(\busing\s+static\s+|\busing\s+|\bnamespace\s+|\.)\s*/.source + /[_a-zA-Z]\w*(?:\s*\.\s*[_a-zA-Z]\w*)*/.source + /(?=\s*[;{])/.source),
            lookbehind: true,
            inside: {
                'punctuation': /\./
            }
        },
        'type-expression': {
            pattern: RegExp(/(\b(?:default|typeof|sizeof)\s*\(\s*|\b(?:checked|unchecked)\s*\(\s*|\(/.source + /[_a-zA-Z]\w*(?:\s*\.\s*[_a-zA-Z]\w*)*/.source + /(?:\s*\?)?\s*\)|\b(?:as|is)\s+)/.source + /[_a-zA-Z]\w*(?:\s*\.\s*[_a-zA-Z]\w*)*/.source + /(?:\s*\?)?\s*(?:\[(?:\s*,\s*)*\])?/.source + /(?=\s*(?:[-+*/%&|^]|[!=<>]=?|&&?|\|\|?|\?|[.?[\])};,:)]|$))/.source),
            lookbehind: true,
            inside: {
                'keyword': /\b(?:as|is)\b/,
                'punctuation': /[.?[\]]/
            }
        },
        'return-type': {
            pattern: RegExp(/(\b(?:class|interface|new)\s+|\b(?:public|private|protected|internal|static|virtual|abstract|sealed|override|extern)\s+)*/.source + /[_a-zA-Z]\w*(?:\s*\.\s*[_a-zA-Z]\w*)*/.source + /(?:\s*\?)?\s*(?:\[(?:\s*,\s*)*\])?/.source + /(?=\s+(?:[_a-zA-Z]\w*\s*)?(?:=>|[({]|\w+\s*[=,;]))/.source),
            lookbehind: true,
            inside: {
                'keyword': /\b(?:public|private|protected|internal|static|virtual|abstract|sealed|override|extern)\b/,
                'punctuation': /[.?[\]]/
            }
        }
    });

    // JSON
    Prism.languages.json = {
        'property': {
            pattern: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
            greedy: true
        },
        'string': {
            pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
            greedy: true
        },
        'comment': {
            pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
            greedy: true
        },
        'number': /-?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b/,
        'punctuation': /[{}[\],]/,
        'operator': /:/,
        'boolean': /\b(?:true|false)\b/,
        'null': {
            pattern: /\bnull\b/,
            alias: 'keyword'
        }
    };

    // PowerShell
    Prism.languages.powershell = {
        'comment': [
            {
                pattern: /(^|[^`])<#[\s\S]*?#>/,
                lookbehind: true
            },
            {
                pattern: /(^|[^`])#.*/,
                lookbehind: true
            }
        ],
        'string': [
            {
                pattern: /"(?:`[\s\S]|[^`"])*"/,
                greedy: true,
                inside: {
                    'function': {
                        pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
                        lookbehind: true,
                        inside: {}
                    }
                }
            },
            {
                pattern: /'(?:[^']|'')*'/,
                greedy: true
            }
        ],
        'namespace': /\[[a-z](?:\[(?:\[[^\]]*]|[^\[\]])*]|[^\[\]])*]/i,
        'boolean': /\$(?:true|false)\b/i,
        'variable': /\$\w+\b/,
        'function': [
            /\b(?:filter|function)\s+(?:global:)?\w+/,
            /\b(?:workflow|configuration)\s+(?:global:)?\w+/,
            {
                pattern: /(\.)(?:(?:clear|disable|enable|export|format|get|hide|import|invoke|join|limit|move|new|out|pop|push|redo|remove|rename|reset|resize|search|select|set|show|skip|split|step|switch|tee|trace|undo|unlock|watch|write)-)?[\w.-]+\b/,
                lookbehind: true
            },
            {
                pattern: /\b(?:(?:clear|disable|enable|export|format|get|hide|import|invoke|join|limit|move|new|out|pop|push|redo|remove|rename|reset|resize|search|select|set|show|skip|split|step|switch|tee|trace|undo|unlock|watch|write)-)?[\w.-]+\b/
            }
        ],
        'keyword': /\b(?:begin|break|catch|class|continue|data|define|do|dynamicparam|else|elseif|end|enum|exit|filter|finally|for|foreach|from|function|if|in|param|process|return|switch|throw|trap|try|until|using|var|while|workflow|configuration)\b/i,
        'operator': {
            pattern: /(\W?)(?:!|-(?:eq|ne|gt|ge|lt|le|sh[lr]|not|b?(?:and|x?or)|(?:Not)?(?:Like|Match|Contains|In)|Replace|Join|is(?:Not)?|as)\b|[+\-*\/%]=?|[&|]{1,2}|[!=<>]{1,2}|\.\.|\.|::|\?)/i,
            lookbehind: true
        },
        'punctuation': /[|{}[\];(),.]/
    };

    Prism.languages.powershell.string[0].inside.function.inside = Prism.languages.powershell;

    if (typeof window !== 'undefined') {
        window.Prism = Prism;
        
        // Auto-highlight on page load
        if (typeof document !== 'undefined') {
            document.addEventListener('DOMContentLoaded', function() {
                var codes = document.querySelectorAll('pre code[class*="language-"], code[class*="language-"]');
                for (var i = 0; i < codes.length; i++) {
                    var code = codes[i];
                    var language = code.className.match(/language-(\w+)/);
                    if (language && Prism.languages[language[1]]) {
                        code.innerHTML = Prism.highlight(code.textContent, Prism.languages[language[1]], language[1]);
                    }
                }
            });
        }
    }

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = Prism;
    }
})();
